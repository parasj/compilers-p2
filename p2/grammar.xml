<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE grammar [
  <!ELEMENT grammar ANY>
  <!ATTLIST grammar name CDATA #REQUIRED>
  <!ELEMENT productionRule ANY>
  <!ATTLIST productionRule headNonterminal CDATA #REQUIRED>
  <!ELEMENT terminal ANY>
  <!ATTLIST terminal lexeme CDATA #REQUIRED>
  <!ELEMENT nonterminal ANY>
  <!ATTLIST nonterminal name CDATA #REQUIRED>
]>

<grammar name="tiger">

  <!-- rule: program -->
  <productionRule headNonterminal="program">
    <terminal lexeme="let"/>
    <nonterminal name="program" />
    <terminal lexeme="in" />
    <nonterminal name="stmts" />
    <terminal lexeme="end" />
  </productionRule>

  <!-- rule: declseg -->
  <productionRule headNonterminal="declseg">
    <nonterminal name="typedecls" />
    <nonterminal name="vardecls" />
    <nonterminal name="funcdecls" />
  </productionRule>

  <!-- rule: typedecls -->
  <productionRule headNonterminal="typedecls">
    <!-- a terminal with lexeme = empty string is the empty string terminal -->  
    <terminal lexeme="" />
  </productionRule>

  <productionRule headNonterminal="typedecls">
    <nonterminal name="typedecl" />
    <nonterminal name="typedecls" />
  </productionRule>

  <!-- rule: typedecl -->
  <productionRule headNonterminal="typedecl">
    <terminal lexeme="type" />
    <terminal lexeme="id" />
    <terminal lexeme=":=" />
    <nonterminal name="type" />
    <terminal lexeme=";" />
  </productionRule>

  <!-- rule: type -->
  <productionRule headNonterminal="type">
    <terminal lexeme="boolean" />
  </productionRule>

  <productionRule headNonterminal="type">
    <terminal lexeme="int" />
  </productionRule>

  <productionRule headNonterminal="type">
    <terminal lexeme="float" />
  </productionRule>

  <productionRule headNonterminal="type">
    <terminal lexeme="unit" />
  </productionRule>

  <productionRule headNonterminal="type">
    <terminal lexeme="id" />
  </productionRule>

  <productionRule headNonterminal="type">
    <terminal lexeme="array" />
    <terminal lexeme="[" />
    <terminal lexeme="intlit" />
    <terminal lexeme="]" />
    <terminal lexeme="of" />
    <nonterminal name="type" />
  </productionRule>
  
  <!-- rule: vardecls -->
  <productionRule headNonterminal="vardecls">
    <terminal lexeme="" />
  </productionRule>

  <productionRule headNonterminal="vardecls">
    <nonterminal name="vardecl" />
    <nonterminal name="vardecls" />
  </productionRule>

  <!-- rule: vardecl -->
  <productionRule headNonterminal="vardecl">
    <terminal lexeme="var" />
    <nonterminal name="ids" />
    <terminal lexeme=":" />
    <nonterminal name="type" />
    <nonterminal name="optinit" />
    <terminal lexeme=";" />
  </productionRule>

  <!-- rule: ids -->
  <productionRule headNonterminal="ids">
    <terminal lexeme="id" />
  </productionRule>

  <productionRule headNonterminal="ids">
    <terminal lexeme="id" />
    <terminal lexeme="," />
    <nonterminal name="ids" />
  </productionRule>

  <!-- rule: optinit -->
  <productionRule headNonterminal="optinit">
    <terminal lexeme="" />
  </productionRule>

  <productionRule headNonterminal="optinit">
    <terminal lexeme=":=" />
    <nonterminal name="const" />
  </productionRule>

  <!-- rule: funcdecls -->
  <productionRule headNonterminal="funcdecls">
    <terminal lexeme="" />
  </productionRule>

  <productionRule headNonterminal="funcdecls">
    <terminal lexeme="func" />
    <terminal lexeme="id" />
    <terminal lexeme="(" />
    <nonterminal name="params" />
    <terminal lexeme=")" />
    <terminal lexeme=":" />
    <nonterminal name="type" />
    <terminal lexeme="begin" />
    <nonterminal name="stmts" />
    <terminal lexeme="end" />
    <terminal lexeme=";" />
  </productionRule>
</grammar>